<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>areaDetector Photron driver</title>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
</head>
<body>
  <div style="text-align: center">
    <h1>
      areaDetector Photron driver</h1>
    <h2>
      April 5, 2016</h2>
    <h2>
      Kevin Peterson</h2>
    <h2>
      Argonne National Laboratory</h2>
  </div>
  <h2>
    Contents</h2>
  <ul>
    <li><a href="#Overview">Overview</a></li>
    <li><a href="#Differences">Differences from other cameras</a></li>
    <li><a href="#Modes">Operating Modes</a></li>
    <ul>
      <li><a href="#CamMode">Camera Mode</a></li>
      <li><a href="#AcqMode">Acquire Mode</a></li>
    </ul>
    <li><a href="#StandardNotes">Implementation of standard driver parameters</a></li>
    <li><a href="#Driver_parameters">Photron-specific parameters</a></li>
    <li><a href="#Configuration">Configuration</a></li>
    <li><a href="#MEDM_screens">MEDM screens</a></li>
    <li><a href="#ConnectionManagement">Connection management</a></li>
  </ul>
  <h2 id="Overview">
    Overview</h2>
  <p>
    This is an <a href="http://www.aps.anl.gov/epics/">EPICS</a> <a href="http://cars9.uchicago.edu/software/epics/areaDetector.html">
      areaDetector</a> driver for Gigabit Ethernet cameras from <a href="http://www.photron.com">
        Photron</a>. 
        The driver is supported under Windows using the 
        64-bit vendor library.
  </p>
  <p>
    This driver inherits from <a href="areaDetectorDoc.html#ADDriver">ADDriver</a>.
    It implements nearly all of the parameters in <a href="areaDetectorDoxygenHTML/asyn_n_d_array_driver_8h.html">
      asynNDArrayDriver.h</a> and in <a href="areaDetectorDoxygenHTML/_a_d_driver_8h.html">
        ADArrayDriver.h</a>. It also implements a number of parameters that are specific
    to Photron cameras. The Photron class documentation will describe this class in detail, but it doesn't yet exist.</p>
  <h2 id="Differences">
    Differences from other cameras</h2>
  <p>
    Photron cameras differ from the cameras for which areaDetector was designed.
  </p>
  <ul>
    <li>There are multiple modes of operating the camera, and the mode determines how some settings get their values</li>
    <li>Many camera settings are limited to a small list of acceptable values; this includes frame rate and resolution.</li>
    <li>Camera settings are frequently coupled; example: changing the frame rate sometimes changes the resolution.</li>
    <li>The standard acquistion mode involves recording images to the camera's internal memory and reading them out later.</li>
    <li>The readout time is much greater than the acquire time, so it is sometimes desirable to save a subset of images that were acquired.</li>
  </ul>
  <p>
    Some of the unique and important features of the vendor software have been implemented in the areaDetector support, despite not fitting naturally into the areaDetector model.  A non-trivial amount of code in the driver is dedicated to preventing invalid values from being sent to the camera.
  </p>
  <h2 id="Modes">
    Operating Modes</h2>
  <h3 id="CamMode">
    Camera mode</h3>
    <p>
      Camera mode determines how the record rate, resolution, and position are determined.
    </p>
    <table border="1" cellpadding="2" cellspacing="2" style="text-align: center">
      <tbody>
      <tr>
        <th>
          Mode
          </th>
        <th>
          Record Rate</th>
        <th>
          Resolution</th>
        <th>
          Position</th>
        <th>
          Flexibility</th>
        <th>
          Major Changes allowed</th>
      </tr>
      <tr>
        <td>
          Default</td>
        <td>
          Set by record rate PV</td>
        <td>
          Highest resolution automatically <br />
          selected for current record rate</td>
        <td>
          Fixed ROI position <br />
          (Center of sensor) </td>
        <td>
          Moderate</td>
        <td>
          On-the-fly </td>
      </tr>
      <tr>
        <td>
          Variable</td>
        <td>
          Set by record rate of <br />
          current variable channel</td>
        <td>
          Set by resolution of <br />
          current variable channel</td>
        <td>
          Set by position of <br />
          current variable channel*</td>
        <td>
          High</td>
        <td>
          When saving variable </br>
          channel settings</td>
      </tr>
      <tr>
        <td>
          External</td>
        <td>
          Set by frequency of <br />
          pulses on sync input</td>
        <td>
          Highest resolution automatically <br />
          selected for sync-pulse frequency</td>
        <td>
          Fixed ROI position <br />
          (Center of sensor)</td>
        <td>
          Minimal</td>
        <td>
          When external <br />
          mode is enabled</td>
      </tr>
      </tbody>
    </table>
    <p>
      * The degrees of freedom depend on the camera model.
    </p>
  <h3 id="AcqMode">
    Acquire mode</h3>
    <p>
      Acquire mode determines whether or not images are recorded to the internal
      memory of the camera before retrieval.
    </p>
    A camera in <b>live mode</b> behaves like most other areaDetectors:
  <ul>
    <li>Images are requested from the camera one-at-a-time.</li>
    <li>The PVs on the ADCollect screen, with the exception of TriggerMode,
        determine how the images are collected.</li>
    <li>The Acquire PV is used to initiate acquisition.</li>
    <li>Continuous acquistion will be much, much slower than the desired frame rate.</li>
  </ul>
    A camera in <b>record mode</b> behaves very differently than other areaDetectors:
  <ul>
    <li>Images are recorded to the internal memory of the camera.</li>
    <li>The PVs on the Trigger screen determine which & how many images are recorded.</li>
    <li>Many of the PVs on the ADCollect screen (AcquirePeriod, NumImages, NumExposures, ImageMode) are ignored.</li>
    <li>A trigger signal (software or hardware) initiates acquisition. The Acquire PV can be used, but only if the trigger mode results in a single recording.</li>
    <li>Acquisition occurs at the desired frame rate, but images are read from the camera much more slowly.</li>
  </ul>
  <!--h2 id="StandardNotes" style="text-align: left">
    Implementation of standard driver parameters</h2>
  <p>
    The driver redefines the choices for several of the parameters defined in ADDriver.h.
    The ADTriggerMode choices for the Prosilica are:
  </p>
  <ul>
    <li>Free Run (collects images as fast as allowed by the camera readout and the exposure
      time)</li>
    <li>Sync In 1 (external trigger on line 1)</li>
    <li>Sync In 2 (external trigger on line 2)</li>
    <li>Sync In 3 (external trigger on line 3)</li>
    <li>Sync In 4 (external trigger on line 4)</li>
    <li>Fixed Rate (collects images at a fixed rate)</li>
    <li>Software (single software trigger)</li>
  </ul>
  <p>
    The Prosilica supports hardware timing input and output signals that are supported
    in the driver.
  </p>
  <p>
    The NDDataType choices for the Prosilica are:
  </p>
  <ul>
    <li>NDUInt8 (8-bit data)</li>
    <li>NDUInt16 (12 or 16 bit data)</li>
  </ul>
  <p>
    The NDColorMode choices for the Prosilica are:
  </p>
  <ul>
    <li>NDColorModeMono (monochromatic data)</li>
    <li>NDColorModeBayer (raw Bayer data)</li>
    <li>NDColorModeRGB1 (RGB1 data)</li>
  </ul>
  <p>
    The color Prosilica cameras are also capable of various YUV color formats but these
    are not supported in the driver. They may be added in a future release.
  </p-->
  <h2 id="Driver_parameters" style="text-align: left">
    Photron-specific parameters</h2>
  <p>
    The Photron driver implements the following parameters in addition to those in
    asynNDArrayDriver.h and ADDriver.h:
  </p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="7,">
          <b>Parameter Definitions in Photron.cpp and EPICS Record Definitions in Photron.template</b>
        </td>
      </tr>
      <tr>
        <th>
          Parameter index variable</th>
        <th>
          asyn interface</th>
        <th>
          Access</th>
        <th>
          Description</th>
        <th>
          drvInfo string</th>
        <th>
          EPICS record name</th>
        <th>
          EPICS record type</th>
      </tr>
      <tr>
        <td align="center" colspan="7,">
          <b>Operating Mode Parameters</b></td>
      </tr>
      <tr>
        <td>
          PhotronStatus</td>
        <td>
          asynInt32</td>
        <td>
          r</td>
        <td>
          The status of the camera as an integer<br />
          See PDCValue.h for allowed values</td>
        <td>
          PHOTRON_STATUS</td>
        <td>
          $(P)$(R)Status_RBV</td>
        <td>
          longin</td>
      </tr>
      <tr>
        <td>
          PhotronStatusName</td>
        <td>
          asynInt32</td>
        <td>
          r</td>
        <td>
          The human-readable status of the camera</td>
        <td>
          PHOTRON_STATUS_NAME</td>
        <td>
          $(P)$(R)StatusName_RBV</td>
        <td>
          mbbi</td>
      </tr>
      <tr>
        <td>
          PhotronCamMode</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          See <a href="#CamMode">camera-mode</a> section</td>
        <td>
          PHOTRON_CAM_MODE</td>
        <td>
          $(P)$(R)CamMode<br />
          $(P)$(R)CamMode_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
      </tr>
      <tr>
        <td>
          PhotronAcquireMode</td>
        <td>
          asynInt32</td>
        <td>
          w</td>
        <td>
          See <a href="#AcqMode">acquire-mode</a> section</td>
        <td>
          PHOTRON_ACQUIRE_MODE</td>
        <td>
          $(P)$(R)AcquireMode</td>
        <td>
          mbbo</td>
      </tr>
      <tr>
        <td>
          PhotronPreviewMode</td>
        <td>
          asynInt32</td>
        <td>
          w</td>
        <td>
          Enables (1) or disables (0) preview mode<br />
          Only applies when AcquireMode is "Record"</td>
        <td>
          PHOTRON_PREVIEW_MODE</td>
        <td>
          $(P)$(R)PreviewMode</td>
        <td>
          bo</td>
      </tr>
      <tr>
        <td align="center" colspan="7,">
          <b>Acquisition Parameters</b></td>
      </tr>
      <tr>
        <td>
          PhotronRecordRate</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          The desired number of frames per second<br />
          A list of valid values is provided by the camera</td>
        <td>
          PHOTRON_REC_RATE</td>
        <td>
          $(P)$(R)RecordRate<br />
          $(P)$(R)RecordRate_RBV</td>
        <td>
          longout
          <br />
          longin</td>
      </tr>
      <tr>
        <td>
          PhotronChangeRecRate</td>
        <td>
          asynInt32</td>
        <td>
          w</td>
        <td>
          Increases (1) or decreases (0) the record rate</td>
        <td>
          PHOTRON_CHANGE_REC_RATE</td>
        <td>
          $(P)$(R)ChangeRecRate</td>
        <td>
          bo</td>
      </tr>
      <tr>
        <td>
          PhotronResIndex</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          The index for the current resolution<br />
          in the list of valid resolutions</td>
        <td>
          PHOTRON_RES_INDEX</td>
        <td>
          $(P)$(R)ResIdx<br />
          $(P)$(R)ResIdx_RBV</td>
        <td>
          longout
          <br />
          longin</td>
      </tr>
      <tr>
        <td>
          PhotronChangeResIdx</td>
        <td>
          asynInt32</td>
        <td>
          w</td>
        <td>
          Increases (1) or decreases (0) the resolution index</td>
        <td>
          PHOTRON_CHANGE_RES_IDX</td>
        <td>
          $(P)$(R)ChangeResIdx</td>
        <td>
          bo</td>
      </tr>
      <tr>
        <td>
          PhotronShutterFps</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          The shutter speed in Hz. A list of valid<br />
          speeds is provided by the camera</td>
        <td>
          PHOTRON_SHUTTER_FPS</td>
        <td>
          $(P)$(R)ShutterFps<br />
          $(P)$(R)ShutterFps_RBV</td>
        <td>
          longout
          <br />
          longin</td>
      </tr>
      <tr>
        <td>
          PhotronChangeShutterFps</td>
        <td>
          asynInt32</td>
        <td>
          w</td>
        <td>
          Increases (1) or decreases (0) the shutter speed</td>
        <td>
          PHOTRON_CHANGE_SHUTTER_FPS</td>
        <td>
          $(P)$(R)ChangeShutterFps</td>
        <td>
          bo</td>
      </tr>
      <tr>
        <td>
          PhotronJumpShutterFps</td>
        <td>
          asynInt32</td>
        <td>
          w</td>
        <td>
          Jumps to the maximum (1) or minimum (0) shutter speed</td>
        <td>
          PHOTRON_JUMP_SHUTTER_FPS</td>
        <td>
          $(P)$(R)JumpShutterFps</td>
        <td>
          bo</td>
      </tr>
      <tr>
        <td>
          PhotronShadingMode</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Turning the shading mode off (0) and on (1)<br />
          performs the black-level calibration.</td>
        <td>
          PHOTRON_SHADING_MODE</td>
        <td>
          $(P)$(R)ShadingMode<br />
          $(P)$(R)ShadingMode_RBV</td>
        <td>
          mbbo
          <br />
          mbbi</td>
      </tr>
      <tr>
        <td align="center" colspan="7,">
          <b>Trigger parameters</b></td>
      </tr>
      <tr>
        <td>
          PhotronMaxFrames</td>
        <td>
          asynInt32</td>
        <td>
          r</td>
        <td>
          The maximum number of frames that can be<br />
          saved in memory at the current resolution</td>
        <td>
          PHOTRON_MAX_FRAMES</td>
        <td>
          $(P)$(R)MaxFrames_RBV</td>
        <td>
          longin</td>
      </tr>
      <tr>
        <td>
          PhotronAfterFrames</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Number of frames to record after the trigger is received</td>
        <td>
          PHOTRON_AFTER_FRAMES</td>
        <td>
          $(P)$(R)AfterFrames<br />
          $(P)$(R)AfterFrames_RBV</td>
        <td>
          longout
          <br />
          longin</td>
      </tr>
      <tr>
        <td>
          PhotronRandomFrames</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Total number of frames to record</td>
        <td>
          PHOTRON_RANDOM_FRAMES</td>
        <td>
          $(P)$(R)RandomFrames<br />
          $(P)$(R)RandomFrames_RBV</td>
        <td>
          longout
          <br />
          longin</td>
      </tr>
      <tr>
        <td>
          PhotronRecCount</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Number of recordings before camera automatically returns <br />
          to live mode. Limited to 10 when user-selectable.</td>
        <td>
          PHOTRON_REC_COUNT</td>
        <td>
          $(P)$(R)RecCount<br />
          $(P)$(R)RecCount_RBV</td>
        <td>
          longout
          <br />
          longin</td>
      </tr>
      <tr>
        <td>
          PhotronSoftTrig</td>
        <td>
          asynInt32</td>
        <td>
          w</td>
        <td>
          Initiates a recording when AcquireMode is "Record"<br />
          Is ignored when AcquireMode is "Live"</td>
        <td>
          PHOTRON_SOFT_TRIG</td>
        <td>
          $(P)$(R)SoftwareTrigger</td>
        <td>
          busy</td>
      </tr>
      <tr>
        <td>
          PhotronLiveMode</td>
        <td>
          asynInt32</td>
        <td>
          w</td>
        <td>
          Initiates playback for trigger modes w/ multiple recordings
          before the specified number of recordings has been reached.</td>
        <td>
          PHOTRON_LIVE_MODE</td>
        <td>
          $(P)$(R)LiveMode<br /></td>
        <td>
          bo</td>
      </tr>
      <tr>
        <td align="center" colspan="7,">
          <b>Readout parameters</b></td>
      </tr>
      <tr>
        <td>
          IndexVariable</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Description</td>
        <td>
          DRV_INFO_STRING</td>
        <td>
          $(P)$(R)Record<br />
          $(P)$(R)Record_RBV</td>
        <td>
          mbbo
          <br />
          mbbi</td>
      </tr>
      <tr>
        <td>
          IndexVariable</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Description</td>
        <td>
          DRV_INFO_STRING</td>
        <td>
          $(P)$(R)Record<br />
          $(P)$(R)Record_RBV</td>
        <td>
          mbbo
          <br />
          mbbi</td>
      </tr>
      <tr>
        <td>
          IndexVariable</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Description</td>
        <td>
          DRV_INFO_STRING</td>
        <td>
          $(P)$(R)Record<br />
          $(P)$(R)Record_RBV</td>
        <td>
          mbbo
          <br />
          mbbi</td>
      </tr>
      <tr>
        <td>
          IndexVariable</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Description</td>
        <td>
          DRV_INFO_STRING</td>
        <td>
          $(P)$(R)Record<br />
          $(P)$(R)Record_RBV</td>
        <td>
          mbbo
          <br />
          mbbi</td>
      </tr>
      <tr>
        <td>
          IndexVariable</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Description</td>
        <td>
          DRV_INFO_STRING</td>
        <td>
          $(P)$(R)Record<br />
          $(P)$(R)Record_RBV</td>
        <td>
          mbbo
          <br />
          mbbi</td>
      </tr>
      <tr>
        <td>
          IndexVariable</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Description</td>
        <td>
          DRV_INFO_STRING</td>
        <td>
          $(P)$(R)Record<br />
          $(P)$(R)Record_RBV</td>
        <td>
          mbbo
          <br />
          mbbi</td>
      </tr>
      <!-- STUFF TO COPY BELOW -->
      <tr>
        <td>
          IndexVariable</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Description</td>
        <td>
          DRV_INFO_STRING</td>
        <td>
          $(P)$(R)Record<br />
          $(P)$(R)Record_RBV</td>
        <td>
          mbbo
          <br />
          mbbi</td>
      </tr>
      <tr>
        <td align="center" colspan="7,">
          <b>HEADING</b></td>
      </tr>
    </tbody>
  </table>
  <!-- KNOWN PROBLEMS -->
  <!--h2 id="Configuration">
    Configuration</h2>
  <p>
    The Prosilica driver is created with the prosilicaConfig command, either from C/C++
    or from the EPICS IOC shell.</p>
  <pre>int prosilicaConfig(char *portName,
                    const char* cameraId,
                    int maxBuffers, size_t maxMemory,
                    int priority, int stackSize, int maxPvAPIFrames)
  </pre>
  <p>
    The <b>cameraId</b> string can be any of the following:</p>
  <ul>
    <li>The camera's UniqueId, which is a number assigned by the vendor to each Prosilica
      camera, e.g. 50110.</li>
    <li>The camera's IP address, e.g. 164.54.160.48.</li>
    <li>The camera's IP DNS name, e.g. gse-prosilica1.cars.aps.anl.gov.</li>
  </ul>
  <p>
    Using the UniqueId has the advantage that the cameras can be configured to use DHCP,
    and hence have non-predictable TCP/IP addresses. However, if the UniqueId is used
    then the areaDetector IOC must be on the same subnet as the camera, since cameras
    cannot be found by UniqueID through routers. The simplest way to determine the uniqueId
    of a camera is to run the Prosilica GigEViewer application, select the camera, and
    press the "i" icon on the bottom of the main window to show the camera information
    for this camera. The Unique ID will be displayed on the first line in the information
    window.</p>
  <p>
    The IP address or IP DNS name can be used for cameras with fixed IP addresses, and
    <b>must</b> be used for cameras that are not on the local subnet.</p>
  <p>
    The maxPvAPIFrames parameter controls how many frame buffers will be used by the
    PvAPI library. This is the last parameter in the prosilicaConfig command, and if
    it is absent the default value of 2 is used, which is sufficient in most circumstances.
    However, with very high frame rates or busy IOCs increasing this value can reduce
    dropped frames.</p>
  <p>
    For details on the meaning of the other parameters to this function refer to the
    detailed documentation on the prosilicaConfig function in the <a href="areaDetectorDoxygenHTML/prosilica_8cpp.html">
      prosilica.cpp documentation</a> and in the documentation for the constructor for
    the <a href="areaDetectorDoxygenHTML/classprosilica.html">prosilica class</a>.
  </p>
  <p>
    There an example IOC boot directory and startup script (<a href="prosilica_st_cmd.html">iocBoot/iocProsilica/st.cmd)</a>
    provided with areaDetector.
  </p>
  <h2 id="MEDM_screens" style="text-align: left">
    MEDM screens</h2>
  <p>
    The following is the MEDM screen prosilica.adl.
  </p>
  <div style="text-align: center">
    <h3>
      prosilica.adl</h3>
    <img alt="prosilica.png" src="prosilica.png" /></div>
  <p>
    The following is the MEDM screen that provides access to the specific parameters
    for the Prosilica detector.
  </p>
  <div style="text-align: center">
    <h3>
      prosilicaMore.adl</h3>
    <img alt="prosilicaMore.png" src="prosilicaMore.png" /></div>
  <p>
    The following is an IDL <a href="http://cars.uchicago.edu/software/idl/imaging_routines.html#epics_ad_display">
      epics_ad_display</a> screen displaying the Prosilica detector images.
  </p>
  <div style="text-align: center">
    <h3>
      epics_ad_display.pro</h3>
    <img alt="prosilica_tvscl.jpg" src="prosilica_tvscl.jpg" /></div>
  <h2 id="ConnectionManagement">
    Connection management</h2>
  <p>
    The Prosilica driver implements connection management. Cameras do not need to be
    accessible when the IOC starts up, and can be power-cycled or disconnected and reconnected
    from the Ethernet without restarting the IOC.</p>
  <p>
    Whenever a new camera is detected on the network the Prosilica library issues a
    callback to the driver. If the driver is not currently connected to a camera it
    will attempt to connect when receiving the callback. This mechanism should work
    no matter how the camera is identified in the startup script, i.e. by Unique ID,
    IP address, or IP name. It is also possible to manually connect and disconnect the
    camera by using the $(P)$(R)AsynIO.CNCT PV, which is labeled "Connect" and "Disconnect"
    on the medm screen.</p>
  <p>
    If the camera is not accessible when the IOC boots, or is power-cycled then the
    EPICS output records may not match the actual camera settings and readbacks. They
    can be made to agree by processing the output record, e.g. by pressing Enter or
    Return in the medm output widget. In the future this may be improved by sending
    all of the EPICS settings to the camera when it connects, though it is not clear
    if this would always be the desired behavior.
  </p-->
</body>
</html>
